#pragma version 9

// This TEAL was generated by TEALScript v0.59.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createWill(uint64,bytes,bytes,bytes,bytes,bytes,address)uint64
abi_route_createWill:
	byte 0x; dupn 14 // push empty bytes to fill the stack frame for this subroutine's local variables

	// endTime: uint64
	txna ApplicationArgs 7
	btoi

	// nativeTo: byte[]
	txna ApplicationArgs 6
	extract 2 0

	// nativeAmount: byte[]
	txna ApplicationArgs 5
	extract 2 0

	// assetsTo: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// assetsAmount: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// assets: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute createWill(uint64,bytes,bytes,bytes,bytes,bytes,address)uint64
	callsub createWill
	int 1
	return

createWill:
	proto 22 0

	// contracts/WillExec.algo.ts:37
	// rounds = len(nativeAmount) / 8
	frame_dig -5 // nativeAmount: bytes
	len
	int 8
	/
	frame_bury -8 // rounds: uint64

	// contracts/WillExec.algo.ts:38
	// assert(rounds === len(nativeTo) / 32)
	frame_dig -8 // rounds: uint64
	frame_dig -6 // nativeTo: bytes
	len
	int 32
	/
	==
	assert

	// contracts/WillExec.algo.ts:39
	// totalCost =
	//       COST_PER_BOX + // cost of box
	//       MAX_BOX_SIZE * COST_PER_BYTE + // cost of data
	//       64 * COST_PER_BYTE + // cost of key
	//       64 * COST_PER_BYTE
	int 3330500
	frame_bury -9 // totalCost: uint64

	// contracts/WillExec.algo.ts:45
	// i = 0
	int 0
	frame_bury -10 // i: uint64

for_0:
	frame_dig -10 // i: uint64
	frame_dig -8 // rounds: uint64
	<
	bz for_0_end

	// contracts/WillExec.algo.ts:46
	// currentAmountInBytes = extract3(nativeAmount, i * 8, 8)
	frame_dig -5 // nativeAmount: bytes
	frame_dig -10 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -11 // currentAmountInBytes: bytes

	// contracts/WillExec.algo.ts:47
	// totalCost = totalCost + btoi(currentAmountInBytes)
	frame_dig -9 // totalCost: uint64
	frame_dig -11 // currentAmountInBytes: bytes
	btoi
	+
	frame_bury -9 // totalCost: uint64

	// contracts/WillExec.algo.ts:45
	// i = i + 1
	frame_dig -10 // i: uint64
	int 1
	+
	frame_bury -10 // i: uint64
	b for_0

for_0_end:
	// contracts/WillExec.algo.ts:50
	// verifyTxn(this.txnGroup[0], { receiver: this.app.address, amount: { greaterThanEqualTo: totalCost } })
	// verify receiver
	int 0
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	int 0
	gtxns Amount
	frame_dig -9 // totalCost: uint64
	>=
	assert

	// contracts/WillExec.algo.ts:54
	// rounds = len(assetsAmount) / 8
	frame_dig -3 // assetsAmount: bytes
	len
	int 8
	/
	frame_bury -8 // rounds: uint64

	// contracts/WillExec.algo.ts:55
	// assert(rounds === len(assets) / 8 && rounds === len(assetsTo) / 32)
	frame_dig -8 // rounds: uint64
	frame_dig -2 // assets: bytes
	len
	int 8
	/
	==
	dup
	bz skip_and0
	frame_dig -8 // rounds: uint64
	frame_dig -4 // assetsTo: bytes
	len
	int 32
	/
	==
	&&

skip_and0:
	assert

	// contracts/WillExec.algo.ts:57
	// i = 0
	int 0
	frame_bury -12 // i: uint64

for_1:
	frame_dig -12 // i: uint64
	frame_dig -8 // rounds: uint64
	<
	bz for_1_end

	// contracts/WillExec.algo.ts:58
	// currentAssetInBytes = extract3(assets, i * 8, 8)
	frame_dig -2 // assets: bytes
	frame_dig -12 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -13 // currentAssetInBytes: bytes

	// contracts/WillExec.algo.ts:59
	// currentAmountInBytes = extract3(assets, i * 8, 8)
	frame_dig -2 // assets: bytes
	frame_dig -12 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -14 // currentAmountInBytes: bytes

	// contracts/WillExec.algo.ts:61
	// currentAsset = Asset.fromID(btoi(currentAssetInBytes))
	frame_dig -13 // currentAssetInBytes: bytes
	btoi
	frame_bury -15 // currentAsset: asset

	// contracts/WillExec.algo.ts:62
	// currentAmount = btoi(currentAmountInBytes)
	frame_dig -14 // currentAmountInBytes: bytes
	btoi
	frame_bury -16 // currentAmount: uint64

	// if0_condition
	// contracts/WillExec.algo.ts:64
	// this.assetsHelper(currentAsset).exists
	txna Applications 0
	frame_dig -15 // currentAsset: asset
	itob
	app_global_get_ex
	swap
	pop
	bz if0_else

	// if0_consequent
	// contracts/WillExec.algo.ts:65
	// value = this.assetsHelper(currentAsset).value + currentAmount
	frame_dig -15 // currentAsset: asset
	itob
	app_global_get
	frame_dig -16 // currentAmount: uint64
	+
	frame_bury -17 // value: uint64

	// contracts/WillExec.algo.ts:66
	// this.assetsHelper(currentAsset).value = value
	frame_dig -15 // currentAsset: asset
	itob
	frame_dig -17 // value: uint64
	app_global_put
	b if0_end

if0_else:
	// contracts/WillExec.algo.ts:68
	// this.assetsHelper(currentAsset).value = currentAmount
	frame_dig -15 // currentAsset: asset
	itob
	frame_dig -16 // currentAmount: uint64
	app_global_put

if0_end:
	// contracts/WillExec.algo.ts:57
	// i = i + 1
	frame_dig -12 // i: uint64
	int 1
	+
	frame_bury -12 // i: uint64
	b for_1

for_1_end:
	// contracts/WillExec.algo.ts:72
	// i = 0
	int 0
	frame_bury -18 // i: uint64

for_2:
	frame_dig -18 // i: uint64
	frame_dig -8 // rounds: uint64
	<
	bz for_2_end

	// contracts/WillExec.algo.ts:73
	// currentAssetInBytes = extract3(assets, i * 8, 8)
	frame_dig -2 // assets: bytes
	frame_dig -18 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -19 // currentAssetInBytes: bytes

	// contracts/WillExec.algo.ts:74
	// currentAsset = Asset.fromID(btoi(currentAssetInBytes))
	frame_dig -19 // currentAssetInBytes: bytes
	btoi
	frame_bury -20 // currentAsset: asset

	// contracts/WillExec.algo.ts:76
	// value = this.assetsHelper(currentAsset).value
	frame_dig -20 // currentAsset: asset
	itob
	app_global_get
	frame_bury -21 // value: uint64

	// contracts/WillExec.algo.ts:79
	// verifyTxn(this.txnGroup[i + 1], {
	//         xferAsset: currentAsset,
	//         assetAmount: { greaterThanEqualTo: value },
	//         assetReceiver: this.app.address,
	//       })
	frame_dig -18 // i: uint64
	int 1
	+
	store 8 // verifyTxn index

	// verify xferAsset
	load 8 // verifyTxn index
	gtxns XferAsset
	frame_dig -20 // currentAsset: asset
	==
	assert

	// verify assetAmount
	load 8 // verifyTxn index
	gtxns AssetAmount
	frame_dig -21 // value: uint64
	>=
	assert

	// verify assetReceiver
	load 8 // verifyTxn index
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/WillExec.algo.ts:86
	// this.assetsHelper(currentAsset).delete()
	frame_dig -20 // currentAsset: asset
	itob
	app_global_del

	// contracts/WillExec.algo.ts:72
	// i = i + 1
	frame_dig -18 // i: uint64
	int 1
	+
	frame_bury -18 // i: uint64
	b for_2

for_2_end:
	// contracts/WillExec.algo.ts:89
	// assert(endTime > globals.latestTimestamp)
	frame_dig -7 // endTime: uint64
	global LatestTimestamp
	>
	assert

	// contracts/WillExec.algo.ts:92
	// this.currentId.value = this.currentId.value + 1
	byte 0x6964 // "id"
	byte 0x6964 // "id"
	app_global_get
	int 1
	+
	app_global_put

	// contracts/WillExec.algo.ts:94
	// will: Will = {
	//       from: from,
	//       id: this.currentId.value,
	//       assets: assets,
	//       assetsAmount: assetsAmount,
	//       assetsTo: assetsTo,
	//       nativeAmount: nativeAmount,
	//       nativeTo: nativeTo,
	//       endTime: endTime,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x003a // initial head offset
	frame_dig -1 // from: address
	callsub process_static_tuple_element
	byte 0x6964 // "id"
	app_global_get
	itob
	callsub process_static_tuple_element
	frame_dig -2 // assets: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -3 // assetsAmount: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -4 // assetsTo: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -5 // nativeAmount: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -6 // nativeTo: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -7 // endTime: uint64
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -22 // will: Will

	// contracts/WillExec.algo.ts:105
	// this.wills(this.currentId.value).value = will
	byte 0x6964 // "id"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -22 // will: Will
	box_put

	// contracts/WillExec.algo.ts:106
	// return this.currentId.value;
	byte 0x6964 // "id"
	app_global_get
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// increateEndTime(uint64)void
abi_route_increateEndTime:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// willId: uint64
	txna ApplicationArgs 1
	btoi

	// execute increateEndTime(uint64)void
	callsub increateEndTime
	int 1
	return

increateEndTime:
	proto 3 0

	// contracts/WillExec.algo.ts:110
	// will = this.wills(willId).value
	frame_dig -1 // willId: uint64
	itob
	frame_bury -2 // storage key//will

	// contracts/WillExec.algo.ts:111
	// assert(this.txn.sender === will.from)
	txn Sender
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 32
	==
	assert

	// contracts/WillExec.algo.ts:112
	// currentEndTime = this.wills(willId).value.endTime
	frame_dig -1 // willId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 50 8
	btoi
	frame_bury -3 // currentEndTime: uint64

	// contracts/WillExec.algo.ts:113
	// this.wills(willId).value.endTime = currentEndTime + ONE_DAY * 365
	frame_dig -1 // willId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 50
	frame_dig -3 // currentEndTime: uint64
	int 31536000
	+
	itob
	replace3
	frame_dig -1 // willId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// executeWill(uint64)void
abi_route_executeWill:
	byte 0x; dupn 8 // push empty bytes to fill the stack frame for this subroutine's local variables

	// willId: uint64
	txna ApplicationArgs 1
	btoi

	// execute executeWill(uint64)void
	callsub executeWill
	int 1
	return

executeWill:
	proto 10 0

	// contracts/WillExec.algo.ts:117
	// will = this.wills(willId).value
	frame_dig -1 // willId: uint64
	itob
	frame_bury -2 // storage key//will

	// contracts/WillExec.algo.ts:119
	// assert(globals.latestTimestamp >= will.endTime)
	global LatestTimestamp
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 50 8
	btoi
	>=
	assert

	// contracts/WillExec.algo.ts:122
	// rounds = len(will.nativeAmount) / 8
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 46
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	len
	int 8
	/
	frame_bury -3 // rounds: uint64

	// contracts/WillExec.algo.ts:123
	// i = 0
	int 0
	frame_bury -4 // i: uint64

for_3:
	frame_dig -4 // i: uint64
	frame_dig -3 // rounds: uint64
	<
	bz for_3_end

	// contracts/WillExec.algo.ts:124
	// currentAmount = btoi(extract3(will.nativeAmount, i * 8, 8))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 46
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -4 // i: uint64
	int 8
	*
	int 8
	extract3
	btoi
	frame_bury -5 // currentAmount: uint64

	// contracts/WillExec.algo.ts:125
	// currentTo = Address.fromBytes(extract3(will.nativeTo, i * 32, 32))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 48
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -4 // i: uint64
	int 32
	*
	int 32
	extract3
	frame_bury -6 // currentTo: address

	// contracts/WillExec.algo.ts:127
	// sendPayment({
	//         amount: currentAmount,
	//         receiver: currentTo,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/WillExec.algo.ts:128
	// amount: currentAmount
	frame_dig -5 // currentAmount: uint64
	itxn_field Amount

	// contracts/WillExec.algo.ts:129
	// receiver: currentTo
	frame_dig -6 // currentTo: address
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/WillExec.algo.ts:123
	// i = i + 1
	frame_dig -4 // i: uint64
	int 1
	+
	frame_bury -4 // i: uint64
	b for_3

for_3_end:
	// contracts/WillExec.algo.ts:134
	// rounds = len(will.assets) / 32
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 40
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	len
	int 32
	/
	frame_bury -3 // rounds: uint64

	// contracts/WillExec.algo.ts:135
	// i = 0
	int 0
	frame_bury -7 // i: uint64

for_4:
	frame_dig -7 // i: uint64
	frame_dig -3 // rounds: uint64
	<
	bz for_4_end

	// contracts/WillExec.algo.ts:136
	// currentAsset = Asset.fromID(btoi(extract3(will.assets, i * 32, 32)))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 40
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -7 // i: uint64
	int 32
	*
	int 32
	extract3
	btoi
	frame_bury -8 // currentAsset: asset

	// contracts/WillExec.algo.ts:137
	// currentTo = Address.fromBytes(extract3(will.assetsTo, i * 32, 32))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 44
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -7 // i: uint64
	int 32
	*
	int 32
	extract3
	frame_bury -9 // currentTo: address

	// contracts/WillExec.algo.ts:138
	// currentAmount = btoi(extract3(will.assetsAmount, i * 8, 8))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 42
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -7 // i: uint64
	int 8
	*
	int 8
	extract3
	btoi
	frame_bury -10 // currentAmount: uint64

	// contracts/WillExec.algo.ts:140
	// sendAssetTransfer({
	//         xferAsset: currentAsset,
	//         assetAmount: currentAmount,
	//         assetReceiver: currentTo,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/WillExec.algo.ts:141
	// xferAsset: currentAsset
	frame_dig -8 // currentAsset: asset
	itxn_field XferAsset

	// contracts/WillExec.algo.ts:142
	// assetAmount: currentAmount
	frame_dig -10 // currentAmount: uint64
	itxn_field AssetAmount

	// contracts/WillExec.algo.ts:143
	// assetReceiver: currentTo
	frame_dig -9 // currentTo: address
	itxn_field AssetReceiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/WillExec.algo.ts:135
	// i = i + 1
	frame_dig -7 // i: uint64
	int 1
	+
	frame_bury -7 // i: uint64
	b for_4

for_4_end:
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "createWill(address,byte[],byte[],byte[],byte[],byte[],uint64)uint64"
	method "increateEndTime(uint64)void"
	method "executeWill(uint64)void"
	txna ApplicationArgs 0
	match abi_route_createWill abi_route_increateEndTime abi_route_executeWill
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub