#pragma version 9

// This TEAL was generated by TEALScript v0.59.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

verifyNative:
	proto 6 0

	// contracts/WillExec.algo.ts:34
	// rounds = len(nativeAmount) / 8
	frame_dig -1 // nativeAmount: bytes
	len
	int 8
	/
	frame_bury -3 // rounds: uint64

	// contracts/WillExec.algo.ts:35
	// assert(rounds === len(nativeTo) / 32)
	frame_dig -3 // rounds: uint64
	frame_dig -2 // nativeTo: bytes
	len
	int 32
	/
	==
	assert

	// contracts/WillExec.algo.ts:36
	// totalCost =
	//       COST_PER_BOX + // cost of box
	//       MAX_BOX_SIZE * COST_PER_BYTE + // cost of data
	//       2 * 64 * COST_PER_BYTE
	int 3330500
	frame_bury -4 // totalCost: uint64

	// contracts/WillExec.algo.ts:41
	// i = 0
	int 0
	frame_bury -5 // i: uint64

for_0:
	frame_dig -5 // i: uint64
	frame_dig -3 // rounds: uint64
	<
	bz for_0_end

	// contracts/WillExec.algo.ts:42
	// currentAmountInBytes = extract3(nativeAmount, i * 8, 8)
	frame_dig -1 // nativeAmount: bytes
	frame_dig -5 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -6 // currentAmountInBytes: bytes

	// contracts/WillExec.algo.ts:43
	// totalCost = totalCost + btoi(currentAmountInBytes)
	frame_dig -4 // totalCost: uint64
	frame_dig -6 // currentAmountInBytes: bytes
	btoi
	+
	frame_bury -4 // totalCost: uint64

	// contracts/WillExec.algo.ts:41
	// i = i + 1
	frame_dig -5 // i: uint64
	int 1
	+
	frame_bury -5 // i: uint64
	b for_0

for_0_end:
	// contracts/WillExec.algo.ts:46
	// verifyTxn(this.txnGroup[0], { receiver: this.app.address, amount: { greaterThanEqualTo: totalCost } })
	// verify receiver
	int 0
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	int 0
	gtxns Amount
	frame_dig -4 // totalCost: uint64
	>=
	assert
	retsub

verifyAssets:
	proto 14 0

	// contracts/WillExec.algo.ts:50
	// rounds = len(assetsAmount) / 8
	frame_dig -1 // assetsAmount: bytes
	len
	int 8
	/
	frame_bury -4 // rounds: uint64

	// contracts/WillExec.algo.ts:51
	// assert(rounds === len(assets) / 8 && rounds === len(assetsTo) / 32)
	frame_dig -4 // rounds: uint64
	frame_dig -3 // assets: bytes
	len
	int 8
	/
	==
	dup
	bz skip_and0
	frame_dig -4 // rounds: uint64
	frame_dig -2 // assetsTo: bytes
	len
	int 32
	/
	==
	&&

skip_and0:
	assert

	// contracts/WillExec.algo.ts:53
	// i = 0
	int 0
	frame_bury -5 // i: uint64

for_1:
	frame_dig -5 // i: uint64
	frame_dig -4 // rounds: uint64
	<
	bz for_1_end

	// contracts/WillExec.algo.ts:54
	// currentAssetInBytes = extract3(assets, i * 8, 8)
	frame_dig -3 // assets: bytes
	frame_dig -5 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -6 // currentAssetInBytes: bytes

	// contracts/WillExec.algo.ts:55
	// currentAmountInBytes = extract3(assetsAmount, i * 8, 8)
	frame_dig -1 // assetsAmount: bytes
	frame_dig -5 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -7 // currentAmountInBytes: bytes

	// contracts/WillExec.algo.ts:57
	// currentAsset = Asset.fromID(btoi(currentAssetInBytes))
	frame_dig -6 // currentAssetInBytes: bytes
	btoi
	frame_bury -8 // currentAsset: asset

	// contracts/WillExec.algo.ts:58
	// currentAmount = btoi(currentAmountInBytes)
	frame_dig -7 // currentAmountInBytes: bytes
	btoi
	frame_bury -9 // currentAmount: uint64

	// if0_condition
	// contracts/WillExec.algo.ts:60
	// this.assetsHelper(currentAsset).exists
	txna Applications 0
	frame_dig -8 // currentAsset: asset
	itob
	app_global_get_ex
	swap
	pop
	bz if0_else

	// if0_consequent
	// contracts/WillExec.algo.ts:61
	// value = this.assetsHelper(currentAsset).value + currentAmount
	frame_dig -8 // currentAsset: asset
	itob
	app_global_get
	frame_dig -9 // currentAmount: uint64
	+
	frame_bury -10 // value: uint64

	// contracts/WillExec.algo.ts:62
	// this.assetsHelper(currentAsset).value = value
	frame_dig -8 // currentAsset: asset
	itob
	frame_dig -10 // value: uint64
	app_global_put
	b if0_end

if0_else:
	// contracts/WillExec.algo.ts:64
	// this.assetsHelper(currentAsset).value = currentAmount
	frame_dig -8 // currentAsset: asset
	itob
	frame_dig -9 // currentAmount: uint64
	app_global_put

if0_end:
	// contracts/WillExec.algo.ts:53
	// i = i + 1
	frame_dig -5 // i: uint64
	int 1
	+
	frame_bury -5 // i: uint64
	b for_1

for_1_end:
	// contracts/WillExec.algo.ts:68
	// i = 0
	int 0
	frame_bury -11 // i: uint64

for_2:
	frame_dig -11 // i: uint64
	frame_dig -4 // rounds: uint64
	<
	bz for_2_end

	// contracts/WillExec.algo.ts:69
	// currentAssetInBytes = extract3(assets, i * 8, 8)
	frame_dig -3 // assets: bytes
	frame_dig -11 // i: uint64
	int 8
	*
	int 8
	extract3
	frame_bury -12 // currentAssetInBytes: bytes

	// contracts/WillExec.algo.ts:70
	// currentAsset = Asset.fromID(btoi(currentAssetInBytes))
	frame_dig -12 // currentAssetInBytes: bytes
	btoi
	frame_bury -13 // currentAsset: asset

	// contracts/WillExec.algo.ts:71
	// value = this.assetsHelper(currentAsset).value
	frame_dig -13 // currentAsset: asset
	itob
	app_global_get
	frame_bury -14 // value: uint64

	// contracts/WillExec.algo.ts:73
	// verifyTxn(this.txnGroup[i + 1], {
	//         xferAsset: currentAsset,
	//         assetAmount: { greaterThanEqualTo: value },
	//         assetReceiver: this.app.address,
	//       })
	frame_dig -11 // i: uint64
	int 1
	+
	store 8 // verifyTxn index

	// verify xferAsset
	load 8 // verifyTxn index
	gtxns XferAsset
	frame_dig -13 // currentAsset: asset
	==
	assert

	// verify assetAmount
	load 8 // verifyTxn index
	gtxns AssetAmount
	frame_dig -14 // value: uint64
	>=
	assert

	// verify assetReceiver
	load 8 // verifyTxn index
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/WillExec.algo.ts:79
	// this.assetsHelper(currentAsset).delete()
	frame_dig -13 // currentAsset: asset
	itob
	app_global_del

	// contracts/WillExec.algo.ts:68
	// i = i + 1
	frame_dig -11 // i: uint64
	int 1
	+
	frame_bury -11 // i: uint64
	b for_2

for_2_end:
	retsub

createWillSanityChecks:
	proto 6 0

	// contracts/WillExec.algo.ts:91
	// this.verifyNative(nativeAmount, nativeTo)
	byte 0x; dupn 3 // push empty bytes to fill the stack frame for this subroutine's local variables
	frame_dig -2 // nativeTo: bytes
	frame_dig -1 // nativeAmount: bytes
	callsub verifyNative

	// contracts/WillExec.algo.ts:92
	// this.verifyAssets(assetsAmount, assetsTo, assets)
	byte 0x; dupn 10 // push empty bytes to fill the stack frame for this subroutine's local variables
	frame_dig -5 // assets: bytes
	frame_dig -4 // assetsTo: bytes
	frame_dig -3 // assetsAmount: bytes
	callsub verifyAssets

	// contracts/WillExec.algo.ts:93
	// assert(endTime > globals.latestTimestamp)
	frame_dig -6 // endTime: uint64
	global LatestTimestamp
	>
	assert
	retsub

sendNative:
	proto 2 0

	// contracts/WillExec.algo.ts:97
	// sendPayment({
	//       amount: amount,
	//       receiver: to,
	//       fee: 1000,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/WillExec.algo.ts:98
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// contracts/WillExec.algo.ts:99
	// receiver: to
	frame_dig -1 // to: address
	itxn_field Receiver

	// contracts/WillExec.algo.ts:100
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

sendAsset:
	proto 3 0

	// contracts/WillExec.algo.ts:105
	// sendAssetTransfer({
	//       xferAsset: asset,
	//       assetAmount: amount,
	//       assetReceiver: to,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/WillExec.algo.ts:106
	// xferAsset: asset
	frame_dig -1 // asset: asset
	itxn_field XferAsset

	// contracts/WillExec.algo.ts:107
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/WillExec.algo.ts:108
	// assetReceiver: to
	frame_dig -2 // to: address
	itxn_field AssetReceiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

getCurrentId:
	proto 0 1

	// contracts/WillExec.algo.ts:113
	// return this.currentId.value;
	byte 0x6964 // "id"
	app_global_get
	retsub

incrementCurrentId:
	proto 0 0

	// contracts/WillExec.algo.ts:117
	// this.currentId.value = this.getCurrentId() + 1
	byte 0x6964 // "id"
	callsub getCurrentId
	int 1
	+
	app_global_put
	retsub

// assetOptIn(asset)void
abi_route_assetOptIn:
	// asset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute assetOptIn(asset)void
	callsub assetOptIn
	int 1
	return

assetOptIn:
	proto 1 0

	// contracts/WillExec.algo.ts:121
	// verifyTxn(this.txn, { sender: this.app.creator })
	// verify sender
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/WillExec.algo.ts:122
	// sendAssetTransfer({
	//       assetReceiver: this.app.address,
	//       xferAsset: asset,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/WillExec.algo.ts:123
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/WillExec.algo.ts:124
	// xferAsset: asset
	frame_dig -1 // asset: asset
	itxn_field XferAsset

	// contracts/WillExec.algo.ts:125
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// createWill(uint64,bytes,bytes,bytes,bytes,bytes,address)uint64
abi_route_createWill:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// endTime: uint64
	txna ApplicationArgs 7
	btoi

	// nativeTo: byte[]
	txna ApplicationArgs 6
	extract 2 0

	// nativeAmount: byte[]
	txna ApplicationArgs 5
	extract 2 0

	// assetsTo: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// assetsAmount: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// assets: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute createWill(uint64,bytes,bytes,bytes,bytes,bytes,address)uint64
	callsub createWill
	int 1
	return

createWill:
	proto 9 0

	// contracts/WillExec.algo.ts:139
	// this.createWillSanityChecks(nativeAmount, nativeTo, assetsAmount, assetsTo, assets, endTime)
	frame_dig -7 // endTime: uint64
	frame_dig -2 // assets: bytes
	frame_dig -4 // assetsTo: bytes
	frame_dig -3 // assetsAmount: bytes
	frame_dig -6 // nativeTo: bytes
	frame_dig -5 // nativeAmount: bytes
	callsub createWillSanityChecks

	// contracts/WillExec.algo.ts:142
	// this.incrementCurrentId()
	callsub incrementCurrentId

	// contracts/WillExec.algo.ts:143
	// id = this.getCurrentId()
	callsub getCurrentId
	frame_bury -8 // id: uint64

	// contracts/WillExec.algo.ts:145
	// will: Will = {
	//       from: from,
	//       id: id,
	//       assets: assets,
	//       assetsAmount: assetsAmount,
	//       assetsTo: assetsTo,
	//       nativeAmount: nativeAmount,
	//       nativeTo: nativeTo,
	//       endTime: endTime,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x003a // initial head offset
	frame_dig -1 // from: address
	callsub process_static_tuple_element
	frame_dig -8 // id: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -2 // assets: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -3 // assetsAmount: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -4 // assetsTo: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -5 // nativeAmount: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -6 // nativeTo: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -7 // endTime: uint64
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -9 // will: Will

	// contracts/WillExec.algo.ts:156
	// this.wills(this.currentId.value).value = will
	byte 0x6964 // "id"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -9 // will: Will
	box_put

	// contracts/WillExec.algo.ts:158
	// return id;
	frame_dig -8 // id: uint64
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// increateEndTime(uint64)void
abi_route_increateEndTime:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// willId: uint64
	txna ApplicationArgs 1
	btoi

	// execute increateEndTime(uint64)void
	callsub increateEndTime
	int 1
	return

increateEndTime:
	proto 3 0

	// contracts/WillExec.algo.ts:162
	// will = this.wills(willId).value
	frame_dig -1 // willId: uint64
	itob
	frame_bury -2 // storage key//will

	// contracts/WillExec.algo.ts:163
	// assert(this.txn.sender === will.from)
	txn Sender
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 32
	==
	assert

	// contracts/WillExec.algo.ts:164
	// currentEndTime = this.wills(willId).value.endTime
	frame_dig -1 // willId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 50 8
	btoi
	frame_bury -3 // currentEndTime: uint64

	// contracts/WillExec.algo.ts:165
	// this.wills(willId).value.endTime = currentEndTime + ONE_DAY * 365
	frame_dig -1 // willId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 50
	frame_dig -3 // currentEndTime: uint64
	int 31536000
	+
	itob
	replace3
	frame_dig -1 // willId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// executeWill(uint64)void
abi_route_executeWill:
	byte 0x; dupn 8 // push empty bytes to fill the stack frame for this subroutine's local variables

	// willId: uint64
	txna ApplicationArgs 1
	btoi

	// execute executeWill(uint64)void
	callsub executeWill
	int 1
	return

executeWill:
	proto 10 0

	// contracts/WillExec.algo.ts:169
	// will = this.wills(willId).value
	frame_dig -1 // willId: uint64
	itob
	frame_bury -2 // storage key//will

	// contracts/WillExec.algo.ts:171
	// assert(globals.latestTimestamp >= will.endTime)
	global LatestTimestamp
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 50 8
	btoi
	>=
	assert

	// contracts/WillExec.algo.ts:174
	// rounds = len(will.nativeAmount) / 8
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 46
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	len
	int 8
	/
	frame_bury -3 // rounds: uint64

	// contracts/WillExec.algo.ts:175
	// i = 0
	int 0
	frame_bury -4 // i: uint64

for_3:
	frame_dig -4 // i: uint64
	frame_dig -3 // rounds: uint64
	<
	bz for_3_end

	// contracts/WillExec.algo.ts:176
	// currentAmount = btoi(extract3(will.nativeAmount, i * 8, 8))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 46
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -4 // i: uint64
	int 8
	*
	int 8
	extract3
	btoi
	frame_bury -5 // currentAmount: uint64

	// contracts/WillExec.algo.ts:177
	// currentTo = Address.fromBytes(extract3(will.nativeTo, i * 32, 32))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 48
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -4 // i: uint64
	int 32
	*
	int 32
	extract3
	frame_bury -6 // currentTo: address

	// contracts/WillExec.algo.ts:179
	// this.sendNative(currentTo, currentAmount)
	frame_dig -5 // currentAmount: uint64
	frame_dig -6 // currentTo: address
	callsub sendNative

	// contracts/WillExec.algo.ts:175
	// i = i + 1
	frame_dig -4 // i: uint64
	int 1
	+
	frame_bury -4 // i: uint64
	b for_3

for_3_end:
	// contracts/WillExec.algo.ts:183
	// rounds = len(will.assets) / 32
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 40
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	len
	int 32
	/
	frame_bury -3 // rounds: uint64

	// contracts/WillExec.algo.ts:184
	// i = 0
	int 0
	frame_bury -7 // i: uint64

for_4:
	frame_dig -7 // i: uint64
	frame_dig -3 // rounds: uint64
	<
	bz for_4_end

	// contracts/WillExec.algo.ts:185
	// currentAsset = Asset.fromID(btoi(extract3(will.assets, i * 32, 32)))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 40
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -7 // i: uint64
	int 32
	*
	int 32
	extract3
	btoi
	frame_bury -8 // currentAsset: asset

	// contracts/WillExec.algo.ts:186
	// currentTo = Address.fromBytes(extract3(will.assetsTo, i * 32, 32))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 44
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -7 // i: uint64
	int 32
	*
	int 32
	extract3
	frame_bury -9 // currentTo: address

	// contracts/WillExec.algo.ts:187
	// currentAmount = btoi(extract3(will.assetsAmount, i * 8, 8))
	frame_dig -2 // storage key//will
	box_get
	assert
	store 0 // full array
	int 42
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -7 // i: uint64
	int 8
	*
	int 8
	extract3
	btoi
	frame_bury -10 // currentAmount: uint64

	// contracts/WillExec.algo.ts:189
	// this.sendAsset(currentAsset, currentTo, currentAmount)
	frame_dig -10 // currentAmount: uint64
	frame_dig -9 // currentTo: address
	frame_dig -8 // currentAsset: asset
	callsub sendAsset

	// contracts/WillExec.algo.ts:184
	// i = i + 1
	frame_dig -7 // i: uint64
	int 1
	+
	frame_bury -7 // i: uint64
	b for_4

for_4_end:
	// contracts/WillExec.algo.ts:193
	// this.wills(willId).delete()
	frame_dig -1 // willId: uint64
	itob
	box_del
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "assetOptIn(asset)void"
	method "createWill(address,byte[],byte[],byte[],byte[],byte[],uint64)uint64"
	method "increateEndTime(uint64)void"
	method "executeWill(uint64)void"
	txna ApplicationArgs 0
	match abi_route_assetOptIn abi_route_createWill abi_route_increateEndTime abi_route_executeWill
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub